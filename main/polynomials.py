from time import time
from threading import Thread
import sympy
import utils


LOG = utils.LOG
GROEBNER_TIMEOUT_DEFAULT = 2


@utils.log_start_stop
def zero_set(
        polys, symbols, modulus=2,
        subs_dict=dict(), existence_only=False,
        groebner_timeout=GROEBNER_TIMEOUT_DEFAULT):
    """
    Enumerate points in affine space generated by `symbols` in the intersection of the varieties
    determined by the polys. Like most of our code, this is a knock-off of Sivek's lch.sage code

    :param polys: List of sympy polynomials. Must have commutative variables.
    :param symbols: List of sympy symbols.
    :param modulus: Coefficient modulus.
    :param subs_dict: Dictionary mapping symbols to values which we require to be satisfied.
    :param existence_only: Boolean. Are we just checking existence?
    :param groebner_timeout: compute Groebner bases until timeout is reached. If failed try larger number of simpler problems.
    :return: List of points in the intersection of varieties if existence_only==False else Boolean
        indicating if the zeroset is non-empy.
    """
    LOG.info(f"Searching for zero set of {len(polys)} polynomials in {len(symbols)} variables")
    if modulus == 0:
        raise ValueError("We can only solve for zero sets over Z/mZ with m!=0.")
    if len(symbols) == 0:
        return []
    root = SolutionSearchNode(
        polys=polys,
        symbols=symbols,
        modulus=modulus,
        subs_dict=subs_dict,
        groebner_timeout=groebner_timeout
    )
    nodes = [root]
    spawned_nodes = []
    solution_nodes = []
    loop_counter = 0
    while True:
        LOG.info(f"{loop_counter}th loop of zero_set search: {len(nodes)} nodes, "
                 f"{len(spawned_nodes)} spawned nodes, "
                 f"{len(solution_nodes)} solution nodes")
        loop_counter += 1
        unspawned_nodes = [node for node in nodes if node not in spawned_nodes]
        if len(unspawned_nodes) == 0:
            break
        for node in unspawned_nodes:
            if node.has_solution():
                solution_nodes.append(node)
                # Terminate as early as possible if only checking existence
                if existence_only:
                    return True
            nodes += node.get_spawn()
            spawned_nodes.append(node)
    if existence_only:
        return len(solution_nodes) > 0
    return [node.subs_dict for node in solution_nodes]


@utils.log_start_stop
def ideal_basis(polys, symbols, modulus):
    """Get a simplified basis of the idea generated by polys in GF(modulus)[symbols]"""
    # grlex is much faster than lex! This unbroke some aug searches.
    # sympy has 'buchberger' and 'f5b' methods for Groebner bases. It seems f5b is more up-to-date from googling...
    # https://github.com/sympy/sympy/blob/master/sympy/polys/groebnertools.py
    return sympy.GroebnerBasis(polys, *symbols, modulus=modulus, order='grlex', method='f5b').polys


def finite_field_elements(modulus):
    return [n for n in range(modulus)]


def is_linear(poly):
    """
    :param poly: polynomial
    :return: Bool... is linear or not
    """
    if poly == 0:
        return True
    poly = sympy.sympify(poly)
    coeff_dict = poly.as_coefficients_dict()
    for k in list(coeff_dict.keys()):
        if not k.is_symbol:
            return False
    return True


@utils.log_start_stop
def highest_frequency_symbol(polys, symbols):
    """For a collection of polynomials, find the symbol (variable) which appears which greatest frequency

    :param polys: list of polynomials
    :param symbols: list of symbols
    :return: symbol
    """
    # Ensure that the order of symbols in input match those in polys by re-initializing
    polys = [sympy.Poly(p, *symbols) for p in polys]
    counter = {g: 0 for g in symbols}
    for p in polys:
        monoms = p.monoms()
        for m in monoms:
            for i in range(len(symbols)):
                if m[i] != 0:
                    # Here we are not weighting by powers! I think that this should not make a huge
                    # difference for LCH computations as there should be no monomials divisible
                    # by squares (eg. 1 + x + x*x*y) appearing in a plat.
                    counter[symbols[i]] += 1
    highest_freq = max(counter.values())
    highest_freq_symbols = [g for g in symbols if counter[g] == highest_freq]
    return highest_freq_symbols[0]


class SolutionSearchNode(object):

    def __init__(self, polys, symbols, modulus, subs_dict, groebner_timeout=GROEBNER_TIMEOUT_DEFAULT):
        self.polys = [sympy.Poly(p, *symbols, modulus=modulus) for p in polys]
        self.symbols = symbols
        self.modulus = modulus
        self.subs_dict = subs_dict
        self.groebner_timeout = groebner_timeout
        self.TERMINAL = False
        self.UNSOLVEABLE = False
        if (len(self.polys) > 0) and (len(self.get_unset_vars()) > 0):
            self._apply_subs()
            self._update_subs_and_polys()
        self._check_unset_vars()

    def get_unset_vars(self):
        """
        :return: list of symbols not already set by self.subs_dict
        """
        return [g for g in self.symbols if g not in self.subs_dict.keys()]

    def has_solution(self):
        """
        :return: Bool for if the node has an already set solution
        """
        return self.TERMINAL and (not self.UNSOLVEABLE)

    @utils.log_start_stop
    def get_spawn(self):
        output = []
        if self.TERMINAL:
            return output
        # We choose the symbol which appears in the most monomials
        g = highest_frequency_symbol(polys=self.polys, symbols=self.get_unset_vars())
        for c in finite_field_elements(modulus=self.modulus):
            subs = self.subs_dict.copy()
            subs[g] = c
            output.append(
                SolutionSearchNode(
                    polys=self.polys,
                    symbols=self.symbols,
                    modulus=self.modulus,
                    subs_dict=subs
                )
            )
        return output


    def _check_unset_vars(self):
        if len(self.get_unset_vars()) == 0:
            self.TERMINAL = True


    @utils.log_start_stop
    def _update_subs_and_polys(self):
        """Update self.subs_dict and self.polys

        :return: None
        """
        n_unset_vars = len(self.get_unset_vars())
        if n_unset_vars == 0:
            self.TERMINAL = True
            return
        n_polys = len(self.polys)
        if n_polys == 0:
            return
        while not self.UNSOLVEABLE:
            LOG.info(f"Update substitutions in SolutionSearchNode with {n_unset_vars} unset vars & {n_polys} polys")
            # Keep trying to simplify using brute force substitutions
            start_unset_vars = len(self.get_unset_vars())
            self._check_for_linear_polys()
            self._check_for_const_polys()
            n_unset_vars = len(self.get_unset_vars())
            n_polys = len(self.polys)
            # Break and try Groebner if there was no effect
            if start_unset_vars == n_unset_vars:
                break
        LOG.info(f"After linear and constant term analysis: {n_unset_vars} unset vars & {n_polys} polys")
        if self.UNSOLVEABLE:
            self.TERMINAL = True
            return
        if len(self.get_unset_vars()) == 0:
            self.TERMINAL = True
            return
        modified = self._simplify_polys()
        if modified:
            self._update_subs_and_polys()

    """
    @utils.log_start_stop
    def _update_subs_and_polys(self):
        n_unset_vars = len(self.get_unset_vars())
        if n_unset_vars == 0:
            self.TERMINAL = True
            return
        n_polys = len(self.polys)
        if n_polys == 0:
            return
        LOG.info(f"Update substitutions in SolutionSearchNode with {n_unset_vars} unset vars & {n_polys} polys")
        self._apply_subs()
        self._check_for_const_polys()
        if self.UNSOLVEABLE:
            return
        self._simplify_polys()
        self._check_for_const_polys()
        modified = False
        if not self.UNSOLVEABLE:
            modified = self._check_for_linear_polys()
        if len(self.get_unset_vars()) == 0:
            self.TERMINAL = True
            return
        if modified:
            self._update_subs_and_polys()
    """

    def _apply_subs(self, specific_subs=dict()):
        """Update self.polys by applying substitutions in self.subs_dict or specific_subs

        :param specific_subs: dict or None... substitutions to apply to self.polys
        :return: None
        """
        self.polys = utils.unique_elements([p.subs(specific_subs).subs(self.subs_dict) for p in self.polys])

    @utils.log_start_stop
    def _simplify_polys(self):
        """Attempt to simplify ideal for polynomials using Groebner bases until timeout.
        A separate thread is used to monitor the timeout.
        If the timeout is reached, we give up, passing to the splitting into separate (simpler) nodes.
        Returns True/False for if self.polys has been modified.

        :return: Bool
        """
        modified = False
        start_time = time()
        # Passing a mutable object to the thread which can be modified. See https://stackoverflow.com/a/6894023
        new_basis = {"polys": None}
        thread_kwargs = {
            "results": new_basis, "polys": self.polys, "symbols": self.symbols, "modulus": self.modulus
        }
        def new_ideal_basis(results, polys, symbols, modulus):
            results["polys"] = ideal_basis(polys=polys, symbols=symbols, modulus=modulus)
        ideal_basis_thread = Thread(target=new_ideal_basis, kwargs=thread_kwargs)
        run_time = 0
        thread_timeout = False
        ideal_basis_thread.start()
        while ideal_basis_thread.is_alive() and not thread_timeout:
            run_time = time() - start_time
            thread_timeout = run_time > self.groebner_timeout
        del ideal_basis_thread
        if not thread_timeout:
            new_polys = new_basis["polys"]
            if set(self.polys) != set(new_polys):
                LOG.info(f"Groebner simplified {len(self.polys)} polys to {len(new_polys)}")
                self.polys = new_polys
                modified = True
        else:
            LOG.info(f"Failed to compute Groebner basis after {run_time}s")
        return modified

    @utils.log_start_stop
    def _check_for_const_polys(self):
        """Check for appearances of constant polynomials.
        If zero, throw them out.
        If non-zero there can be no solutions.

        :return: Bool... where subs or polynomials modified?
        """
        modified = False
        if 0 in self.polys:
            self.polys.remove(0)
            modified = True
        for c in [c for c in finite_field_elements(modulus=self.modulus) if c != 0]:
            if c in self.polys:
                self.TERMINAL = True
                self.UNSOLVEABLE = True
                modified = True
        return modified

    @utils.log_start_stop
    def _check_for_linear_polys(self):
        """Check for appearances of linear terms in self.polys.
        If any are found, apply manual substitutions.

        :return: Bool... where subs of polynomials modified?
        """
        modified = False
        for c in finite_field_elements(modulus=self.modulus):
            for g in self.get_unset_vars():
                if g - c in self.polys:
                    self.polys.remove(g - c)
                    self.subs_dict[g] = c
                    self._apply_subs(specific_subs={g: c})
                    modified = True
        return modified
