from collections import Counter
from time import time
from threading import Thread
import sympy
import utils


LOG = utils.LOG
GROEBNER_TIMEOUT_DEFAULT = 1
UNSET_VAR = None


@utils.log_start_stop
def zero_set(
        polys, symbols, modulus=2,
        subs_dicts=[dict()], existence_only=False,
        groebner_timeout=GROEBNER_TIMEOUT_DEFAULT,
        allow_unset=False):
    """
    Enumerate points in affine space generated by `symbols` in the intersection of the varieties
    determined by the polys. Like most of our code, this is a knock-off of Sivek's lch.sage code.

    We use depth first search so that it if augmentations exist you can more quickly track their existence by watching
    logs from the command line.

    :param polys: List of sympy polynomials. Must have commutative variables.
    :param symbols: List of sympy symbols.
    :param modulus: Coefficient modulus.
    :param subs_dicts: List of dicts mapping symbols to values which we require to be satisfied.
    :param existence_only: Boolean. Are we just checking existence?
    :param groebner_timeout: compute Groebner bases until timeout is reached. If failed try larger number of simpler problems.
    :param allow_unset: Bool. If a variable is arbitrary, we make it UNSET_VAR.
    :return: List of points in the intersection of varieties if existence_only==False else Boolean
        indicating if the zeroset is non-empy.
    """
    LOG.info(f"Searching for zero set of {len(polys)} polynomials in {len(symbols)} variables")
    if modulus == 0:
        raise ValueError("We can only solve for zero sets over Z/mZ with m!=0.")
    roots = [
        SolutionSearchNode(
            polys=polys,
            symbols=symbols,
            modulus=modulus,
            subs_dict=subs_dict,
            groebner_timeout=groebner_timeout,
            allow_unset=allow_unset
        )
        for subs_dict in subs_dicts
    ]
    nodes = roots
    spawned_nodes = []
    solution_nodes = []
    loop_counter = 0
    while True:
        LOG.info(f"{loop_counter}th loop of zero_set search: {len(nodes)} nodes, "
                 f"{len(spawned_nodes)} spawned nodes, "
                 f"{len(solution_nodes)} solution nodes")
        loop_counter += 1
        unspawned_nodes = [node for node in nodes if node not in spawned_nodes]
        if len(unspawned_nodes) == 0:
            break
        for node in unspawned_nodes:
            spawned_nodes.append(node)
            if node.has_solution():
                solution_nodes.append(node)
                # Terminate as early as possible if only checking existence
                if existence_only:
                    return True
            else:
                # Search depth first by spawning at the first unspawned node
                nodes = node.get_spawn() + nodes
                break
    if existence_only:
        return len(solution_nodes) > 0
    return [node.subs_dict for node in solution_nodes]


@utils.log_start_stop
def batch_zero_set(polys, symbols, modulus=2, groebner_timeout=GROEBNER_TIMEOUT_DEFAULT, batch_size=10):
    """
    Enumerate points in affine space generated by `symbols` in the intersection of the varieties determined by
    the polys. The batch implementation proceeds by iteratively adding new variables and new polynomials in batches.

    Should only be necessary when there are eg. > 100 polys.

    :param polys: List of sympy polynomials. Must have commutative variables.
    :param symbols: List of sympy symbols.
    :param modulus: Coefficient modulus.
    :param groebner_timeout: compute Groebner bases until timeout is reached.
        If failed try larger number of simpler problems.
    :param batch_size: Size of batches used.
    :return: List of points in the intersection of varieties if existence_only==False else Boolean
        indicating if the zeroset is non-empy.
    """
    LOG.info(f"Searching for (batch) zero set of {len(polys)} polynomials in {len(symbols)} variables")
    if modulus == 0:
        raise ValueError("We can only solve for zero sets over Z/mZ with m!=0.")
    if batch_size <= 0:
        raise ValueError(f"Need batch_size={batch_size} at least 1")
    poly_to_symbols = {p: poly_symbols(p) for p in polys}
    # Frequencies of symbols will help isolate those which occur most often
    ## Could just try to find zeros determined by polynomials having the most frequent symbols
    ## eg. take top 10 symbols appearing most frequently. then polys defined in terms of those symbols
    symbol_freq = Counter()
    for symbol_set in poly_to_symbols.values():
        symbol_freq.update(list(symbol_set))
    symbol_freq = dict(symbol_freq)
    analyzed_polys = []
    analyzed_symbols = set()
    subs_dicts = [dict()]
    loop_counter = 0
    n_analyzed_symbols = 0
    while len(analyzed_polys) < len(polys) and len(subs_dicts) > 0:
        """
        new_polys = []
        while len(new_polys) == 0:
            # How many new variables will the addition of each polynomial introduce?
            poly_to_new_var_counts = {
                k: len(v.difference(analyzed_symbols))
                for k, v in poly_to_symbols.items()
                if k not in analyzed_polys
            }
            # Figure out the minimum number of new variables we need to introduce in order to analyze more polynomials
            count = 0
            while count not in poly_to_new_var_counts.values():
                count += 1
            count_polys = [k for k, v in poly_to_new_var_counts.items() if v == count]
            # If we have to add new variables. Only add the least possible...
            # Can update this to find the variable with most frequent occurrences
            if count != 0:
                # what symbols appear in the polynomials with minimum amounts of new vars
                new_symbols = set()
                for p in count_polys:
                    new_symbols.update(poly_to_symbols[p])
                new_symbols = [sym for sym in new_symbols if sym not in analyzed_symbols]
                new_symbols_counts = {k: v for k, v in symbol_freq.items() if k in new_symbols}
                # List of new symbols sorted by their frequency
                new_symbols = sorted(new_symbols, key=lambda sym: new_symbols_counts[sym], reverse=True)
                # Eliminate already analyzed symbols... Since count!=0 should be non-empty
                n_new_symbols = max([len(new_symbols), chunk_size])
                analyzed_symbols.update(set(new_symbols[:n_new_symbols]))
            new_polys = [
                k for k,v in poly_to_symbols.items()
                if v.issubset(analyzed_symbols) and k not in analyzed_polys
            ]
        # ANOTHER ATTEMPT
        poly_to_new_var_counts = {
            k: len(v.difference(analyzed_symbols))
            for k, v in poly_to_symbols.items()
            if k not in analyzed_polys
        }
        if 0 in poly_to_new_var_counts.values():
            new_polys = [k for k, v in poly_to_new_var_counts.items() if v == 0]
        else:
            # We want to add a chunk_size many variables at a time
            # It seems that choosing 1 means many iterations,
            # whereas choosing chunk_size too large means processing many variables
            poly_to_new_var_counts_chunky = {
                k: v for k, v in poly_to_new_var_counts.items()
                if v <= chunk_size
            }
            new_polys = sorted(list(poly_to_new_var_counts_chunky.keys()), key=lambda k: poly_to_new_var_counts[k])
            new_poly = new_polys[-1]
            LOG.info(f"New poly: {new_poly}")
            analyzed_symbols.update(poly_to_symbols[new_poly])
            new_polys = [
                k for k, v in poly_to_symbols.items()
                if v.issubset(analyzed_symbols) and k not in analyzed_polys
            ]
        """
        # We want to add new variables so that the ratio of new_polys / new_vars is the highest
        # This pattern gives a hueristic
        unanalyzed_symbols = [x for x in symbols if x not in analyzed_symbols]
        unanalyzed_symbols.sort(key=lambda k: symbol_freq[k])
        new_symbols = []
        new_polys = []
        while len(unanalyzed_symbols) > 0 and len(new_polys) <= batch_size:
            new_symbols.append(unanalyzed_symbols.pop())
            analyzed_symbols.update(set(new_symbols))
            new_polys = [
                k for k, v in poly_to_symbols.items()
                if v.issubset(analyzed_symbols) and k not in analyzed_polys
            ]
        LOG.info(f"Analysis on {loop_counter}th iteration of batch_zero_set:\n"
                 f"    n possible augmentations: {len(subs_dicts)}\n"
                 f"    n analyzed variables: {n_analyzed_symbols}\n"
                 f"    n analyzed polynomials: {len(analyzed_polys)}\n"
                 f"    n new variables: {len(analyzed_symbols) - n_analyzed_symbols}\n"
                 f"    n new polynomials: {len(new_polys)}\n"
                 f"    new polynomials: {new_polys}")
        analyzed_polys += new_polys
        n_analyzed_symbols = len(analyzed_symbols)
        loop_counter += 1
        subs_dicts = zero_set(
            polys=new_polys,
            symbols=list(analyzed_symbols),
            modulus=modulus,
            subs_dicts=subs_dicts,
            groebner_timeout=groebner_timeout,
            allow_unset=True
        )

    return subs_dicts


def ideal_basis(polys, symbols, modulus):
    """Get a simplified basis of the idea generated by polys in GF(modulus)[symbols]"""
    # grlex is much faster than lex! This unbroke some aug searches.
    # sympy has 'buchberger' and 'f5b' methods for Groebner bases. It seems f5b is more up-to-date from googling...
    # https://github.com/sympy/sympy/blob/master/sympy/polys/groebnertools.py
    return utils.unique_elements(
        sympy.GroebnerBasis(polys, *symbols, modulus=modulus, order='grlex', method='f5b').polys
    )


def finite_field_elements(modulus):
    return [n for n in range(modulus)]


def is_linear(poly):
    """Is the polynomial linear? This is not the same as being affine :)

    :param poly: polynomial
    :return: Bool... is linear or not
    """
    if poly == 0:
        return True
    poly = sympy.sympify(poly)
    coeff_dict = poly.as_coefficients_dict()
    for k in list(coeff_dict.keys()):
        if not k.is_symbol:
            return False
    return True


def poly_symbols(poly):
    """Return a list of symbols which appears in a polynomial expression

    :param poly:
    :return:
    """
    # TODO: Requires testing
    output = set()
    poly = sympy.sympify(poly)
    coeff_dict = poly.as_coefficients_dict()
    for k in list(coeff_dict.keys()):
        if k.is_number:
            continue
        for x in k.as_terms()[-1]:
            output.add(x)
    return output


def highest_frequency_symbol(polys, symbols):
    """For a collection of polynomials, find the symbol (variable) which appears which greatest frequency

    :param polys: list of polynomials
    :param symbols: list of symbols
    :return: symbol
    """
    # Ensure that the order of symbols in input match those in polys by re-initializing
    polys = [sympy.Poly(p, *symbols) for p in polys]
    counter = {g: 0 for g in symbols}
    for p in polys:
        monoms = p.monoms()
        for m in monoms:
            for i in range(len(symbols)):
                if m[i] != 0:
                    # Here we are not weighting by powers! I think that this should not make a huge
                    # difference for LCH computations as there should be no monomials divisible
                    # by squares (eg. 1 + x + x*x*y) appearing in a plat.
                    counter[symbols[i]] += 1
    highest_freq = max(counter.values())
    highest_freq_symbols = [g for g in symbols if counter[g] == highest_freq]
    return highest_freq_symbols[0]


class SolutionSearchNode(object):

    def __init__(self, polys, symbols, modulus, subs_dict,
                 groebner_timeout=GROEBNER_TIMEOUT_DEFAULT, allow_unset=False):
        self.polys = [sympy.Poly(p, *symbols, modulus=modulus) for p in polys]
        self.symbols = symbols
        self.modulus = modulus
        self.subs_dict = subs_dict
        self.groebner_timeout = groebner_timeout
        self.allow_unset = allow_unset
        self.TERMINAL = False
        self.UNSOLVEABLE = False
        self._setup_subs()
        if (len(self.polys) > 0) and (len(self.get_unset_vars()) > 0):
            self._apply_subs()
            self._update_subs_and_polys()
        self._cleanup_subs()
        self._check_unset_vars()

    def get_unset_vars(self):
        """
        :return: list of symbols not already set by self.subs_dict
        """
        return [g for g in self.symbols if g not in self.subs_dict.keys()]

    def has_solution(self):
        """
        :return: Bool for if the node has an already set solution
        """
        return self.TERMINAL and (not self.UNSOLVEABLE)

    def get_spawn(self):
        output = []
        if self.TERMINAL:
            return output
        # We choose the symbol which appears in the most monomials
        g = highest_frequency_symbol(polys=self.polys, symbols=self.get_unset_vars())
        for c in finite_field_elements(modulus=self.modulus):
            subs = self.subs_dict.copy()
            subs[g] = c
            output.append(
                SolutionSearchNode(
                    polys=self.polys,
                    symbols=self.symbols,
                    modulus=self.modulus,
                    subs_dict=subs
                )
            )
        return output

    def _setup_subs(self):
        if self.allow_unset:
            for k, v in self.subs_dict.items():
                if v is UNSET_VAR:
                    del self.subs_dict[k]

    def _cleanup_subs(self):
        if self.allow_unset:
            if len(self.polys) == 0:
                for g in self.get_unset_vars():
                    self.subs_dict[g] = UNSET_VAR


    def _check_unset_vars(self):
        if len(self.get_unset_vars()) == 0:
            self.TERMINAL = True


    def _update_subs_and_polys(self):
        """Update self.subs_dict and self.polys

        :return: None
        """
        n_unset_vars = len(self.get_unset_vars())
        if n_unset_vars == 0:
            self.TERMINAL = True
            return
        n_polys = len(self.polys)
        if n_polys == 0:
            return
        while not self.UNSOLVEABLE:
            LOG.info(f"Update substitutions in SolutionSearchNode with {n_unset_vars} unset vars & {n_polys} polys")
            # Keep trying to simplify using brute force substitutions
            start_unset_vars = len(self.get_unset_vars())
            self._check_for_linear_polys()
            self._check_for_const_polys()
            n_unset_vars = len(self.get_unset_vars())
            n_polys = len(self.polys)
            # Break and try Groebner if there was no effect
            if start_unset_vars == n_unset_vars:
                break
        LOG.info(f"After linear and constant term analysis: {n_unset_vars} unset vars & {n_polys} polys")
        if self.UNSOLVEABLE:
            self.TERMINAL = True
            return
        if len(self.get_unset_vars()) == 0:
            self.TERMINAL = True
            return
        modified = self._simplify_polys()
        if modified:
            self._update_subs_and_polys()

    def _apply_subs(self, specific_subs=None):
        """Update self.polys by applying substitutions in self.subs_dict or specific_subs

        :param specific_subs: dict or None... substitutions to apply to self.polys
        :return: None
        """
        if specific_subs is not None:
            self.polys = utils.unique_elements([p.subs(specific_subs) for p in self.polys])
        else:
            self.polys = utils.unique_elements([p.subs(self.subs_dict) for p in self.polys])

    # this appears to be useless unless the number of variables is very small
    def _simplify_polys(self):
        """Attempt to simplify ideal for polynomials using Groebner bases until timeout.
        A separate thread is used to monitor the timeout.
        If the timeout is reached, we give up, passing to the splitting into separate (simpler) nodes.
        Returns True/False for if self.polys has been modified.

        :return: Bool
        """
        modified = False
        start_time = time()
        # Passing a mutable object to the thread which can be modified. See https://stackoverflow.com/a/6894023
        new_basis = {"polys": None}
        thread_kwargs = {
            "results": new_basis, "polys": self.polys, "symbols": self.symbols, "modulus": self.modulus
        }
        def new_ideal_basis(results, polys, symbols, modulus):
            results["polys"] = ideal_basis(polys=polys, symbols=symbols, modulus=modulus)
        ideal_basis_thread = Thread(target=new_ideal_basis, kwargs=thread_kwargs)
        run_time = 0
        thread_timeout = False
        ideal_basis_thread.start()
        while ideal_basis_thread.is_alive() and not thread_timeout:
            run_time = time() - start_time
            thread_timeout = run_time > self.groebner_timeout
        del ideal_basis_thread
        if not thread_timeout:
            grob_polys = new_basis["polys"]
            if set(self.polys) != set(grob_polys):
                LOG.info(f"Groebner simplified {len(self.polys)} polys to {len(grob_polys)}")
                # How is it possible that I see Groebner making the polynomial sets larger!?
                # I've witnessed this and want to always shrink the number of generators.
                if len(grob_polys) <= len(self.polys):
                    self.polys = grob_polys
                    modified = True
        else:
            LOG.info(f"Failed to compute Groebner basis after {run_time}s")
        return modified

    def _check_for_const_polys(self):
        """Check for appearances of constant polynomials.
        If zero, throw them out.
        If non-zero there can be no solutions.

        :return: Bool... where subs or polynomials modified?
        """
        modified = False
        if 0 in self.polys:
            self.polys.remove(0)
            modified = True
        # should make finite field elements a node attribute to save time repeating this...
        for c in [c for c in finite_field_elements(modulus=self.modulus) if c != 0]:
            if c in self.polys:
                self.TERMINAL = True
                self.UNSOLVEABLE = True
                modified = True
        return modified

    def _check_for_linear_polys(self):
        """Check for appearances of linear terms in self.polys.
        If any are found, apply manual substitutions.

        :return: Bool... where subs of polynomials modified?
        """
        modified = False
        for c in finite_field_elements(modulus=self.modulus):
            for g in self.get_unset_vars():
                if g - c in self.polys:
                    self.polys.remove(g - c)
                    self.subs_dict[g] = c
                    self._apply_subs(specific_subs={g: c})
                    modified = True
        return modified
